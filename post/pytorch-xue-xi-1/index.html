<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>pytorch学习-1 | maktubの圆</title>
<link rel="shortcut icon" href="https://AnonymityToAll.github.io/favicon.ico?v=1605180882674">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://AnonymityToAll.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="pytorch学习-1 | maktubの圆 - Atom Feed" href="https://AnonymityToAll.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="pytorch-tutorial-tutorial-01-basics-pytorch_basics-main.py
第一个例子，说明如何自动计算偏导数


在运行代码
x = torch.tensor(1, requires_grad=T..." />
    <meta name="keywords" content="深度学习-pytorch" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://AnonymityToAll.github.io">
  <img class="avatar" src="https://AnonymityToAll.github.io/images/avatar.png?v=1605180882674" alt="">
  </a>
  <h1 class="site-title">
    maktubの圆
  </h1>
  <p class="site-description">
    向死而生
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/AnonymityToAll?tab=repositories" target="_blank">
          <i class="ri-github-line"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              pytorch学习-1
            </h2>
            <div class="post-info">
              <span>
                2020-11-12
              </span>
              <span>
                7 min read
              </span>
              
                <a href="https://AnonymityToAll.github.io/tag/upx5jIUqD/" class="post-tag">
                  # 深度学习-pytorch
                </a>
              
            </div>
            
              <img class="post-feature-image" src="https://AnonymityToAll.github.io/post-images/pytorch-xue-xi-1.jpg" alt="">
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h1 id="pytorch-tutorial-tutorial-01-basics-pytorch_basics-mainpy">pytorch-tutorial-tutorial-01-basics-pytorch_basics-main.py</h1>
<h3 id="第一个例子说明如何自动计算偏导数">第一个例子，说明如何自动计算偏导数</h3>
<ol>
<li>
<p>在运行代码</p>
<pre><code class="language-python">x = torch.tensor(1, requires_grad=True)
</code></pre>
<p>时，出现问题</p>
<blockquote>
<p>RuntimeError: Only Tensors of floating point and complex dtype can require gradients</p>
</blockquote>
<p>代码应改为</p>
<pre><code class="language-python">x = torch.tensor(1., requires_grad=True)
</code></pre>
</li>
<li>
<p>pytorch 自动求偏导数的步骤</p>
<pre><code class="language-python"># 自变量，也就是被求导的对象在创建时，要记得把requires_grad=True
x = torch.tensor(1., requires_grad=True)
w = torch.tensor(2., requires_grad=True)
b = torch.tensor(3., requires_grad=True)
# 给出自变量和因变量之间的函数表达式
y = w * x + b
# 然后就让y分别对它们求导即可
y.backward()
</code></pre>
</li>
</ol>
<h3 id="第二个例子说明如何使用模型">第二个例子，说明如何使用模型</h3>
<ol>
<li>
<p>torch.randn(m, n)</p>
<p>标准正态分布，随机抽取m*n个数</p>
</li>
<li>
<p>torch.rand(m, n)</p>
<p>均匀分布，随机抽取m*n个数</p>
</li>
<li>
<p>nn.linear(in_features,  out_features,  bias)</p>
<p>官方文档：https://pytorch.org/docs/master/generated/torch.nn.Linear.html#torch.nn.Linear</p>
<pre><code class="language-python">linear = nn.linear(3, 2)
</code></pre>
<p>我的理解是生成一个全连接层。3代表样本的维数，2代表输出的维数。</p>
</li>
<li>
<p>建立损失函数以及优化函数</p>
<pre><code class="language-python">criterion = nn.MSELoss()
optimizer = torch.optim.SGD(linear.parameters(), lr=0.01)
</code></pre>
</li>
<li>
<p>计算wx+b</p>
<pre><code class="language-python">pred = linear(x)
</code></pre>
</li>
<li>
<p>计算损失函数</p>
<pre><code class="language-python">loss = creterion(pred, y)
</code></pre>
</li>
<li>
<p>损失函数的值为</p>
<pre><code class="language-python">loss.item()
</code></pre>
</li>
<li>
<p>显示损失函数对w，b的偏导数</p>
<pre><code class="language-python">loss.backward()
# 它们的结果分别是
linear.weight.grad
linear.bias.grad
</code></pre>
</li>
<li>
<p>用优化函数优化</p>
<pre><code class="language-python">optimizer.step() # 优化一步
</code></pre>
</li>
<li>
<p>看一下优化之后的损失函数值</p>
<pre><code class="language-python">pred = linear(x)
loss = criterion(pred, y)
</code></pre>
</li>
</ol>
<h3 id="如何从numpy中载入数据">如何从numpy中载入数据</h3>
<pre><code class="language-python">import numpy as np
import torch
x = np.array([[1, 3], [5, 6]])
y = torch.from_numpy(x)
z = y.numpy()
</code></pre>
<h3 id="输入pipline">输入pipline</h3>
<ol>
<li>导入数据</li>
</ol>
<pre><code class="language-python"># 将数据下载下来
from torchvision import transforms
train_dataset = torchvision.datasets.CIFAR10(root='../../data/',
                                             train=True, 
                                             transform=transforms.ToTensor(),
                                             download=True)
</code></pre>
<p>torchvision.datasets说明：https://pytorch.org/docs/stable/torchvision/datasets.html</p>
<p>参数说明：</p>
<blockquote>
<ul>
<li>
<p><strong>root</strong> (<em>string</em>) – Root directory of dataset where directory <code>cifar-10-batches-py</code> exists or will be saved to if download is set to True.</p>
<p>cifar-10-baches-py存放的根目录，或者如果download被设定为True时，cifar-10-baches-py将要被保存的位置</p>
</li>
<li>
<p><strong>train</strong> (<a href="https://docs.python.org/3/library/functions.html#bool"><em>bool</em></a><em>,</em> <em>optional</em>) – If True, creates dataset from training set, otherwise creates from test set.</p>
<p>如果设置为True，从训练集里面创建dataset，否则从测试集里面创建dataset</p>
<p><strong>啥意思？？？？？？？？？？？？？？？？</strong></p>
</li>
<li>
<p><strong>transform</strong> (<em>callable</em>*,* <em>optional</em>) – A function/transform that takes in an PIL image and returns a transformed version. E.g, <code>transforms.RandomCrop</code></p>
<p>一个函数，输入是PIL图片，然后返回一个转换之后的版本，例如transforms.RandomCrop</p>
</li>
<li>
<p><strong>target_transform</strong> (<em>callable</em>*,* <em>optional</em>) – A function/transform that takes in the target and transforms it.</p>
</li>
<li>
<p><strong>download</strong> (<a href="https://docs.python.org/3/library/functions.html#bool"><em>bool</em></a><em>,</em> <em>optional</em>) – If true, downloads the dataset from the internet and puts it in root directory. If dataset is already downloaded, it is not downloaded again.</p>
<p>如果为True，则从互联网下载数据并把它放到根目录里面。如果它已经被下载了，那么则不再下载</p>
</li>
</ul>
</blockquote>
<ol start="2">
<li>
<p>数据说明</p>
<blockquote>
<p>该数据是：一堆彩色图片，若干个图片都是同一类东西。</p>
<pre><code class="language-python">train_dataset.data.shape
# (50000, 32, 32, 3)
len(train_dataset.targets)
# 50000
# 50000 张彩色图片
</code></pre>
<p>参考：https://www.cnblogs.com/Jerry-Dong/p/8109938.html</p>
</blockquote>
</li>
<li>
<p>转换数据</p>
<pre><code class="language-python"># 把train_dataset类的数据转换成tensor类的数据
# 这里只是起到演示作用
# image是图片数据，labels是该类图片数据的标识
image, labels = train_dataset[0]
# 载入数据
# 并把数据分成不同的批次
# 每个批次包含64个数据
# shuffle的意思是shuffle (bool, optional) – set to True to have the data reshuffled at every epoch (default: False).意思是每一个epoch之后，数据都会重新洗牌
#（1）iteration：表示1次迭代，每次迭代更新1次网络结构的参数；
#（2）batch_size：1次迭代所使用的样本量；
#（3）epoch：1个epoch表示过了1遍训练集中的所有样本。
train_loader = torch.utils.data.DataLoader(dataset=train_dataset, batch_size=64, shuffle=True)
# 把train_loader变成迭代器
data_iter = iter(train_loader)
image, labels = data_iter.next()
# 迭代训练集来训练数据
for image, labels in train_loader:
    # 执行训练的操作
    pass
# 这里的image和labels是64维的，也就是说是包含64个样本的
</code></pre>
</li>
</ol>
<h3 id="自定义数据集的输入管道">自定义数据集的输入管道</h3>
<ol>
<li>
<p>你的自定义数据集应该是这样的</p>
<pre><code class="language-python">class CustomDataset(torch.utils.data.Dataset):
    def __init__(self):
        # TODO
        # 1. Initialize file paths or a list of file names. 
        # 初始化文件路径或文件名字的列表
        pass
    def __getitem__(self, index):
        # TODO
        # 1. Read one data from file (e.g. using numpy.fromfile, PIL.Image.open).
        # 从文件中读一个数据
        # 用numpy.fromfile, PIL.Image.open
        # 2. Preprocess the data (e.g. torchvision.Transform).
        # 转换数据到合适的类型
        # 3. Return a data pair (e.g. image and label).
        # 返回一个数据对
        pass
    def __len__(self):
        # You should change 0 to the total size of your dataset.
        # 给出数据的长度
        return 0 
</code></pre>
</li>
<li>
<p>从自定义数据集中读取数据</p>
<pre><code class="language-python">custom_dataset = CustomDataset()
train_loader = torch.utils.data.DataLoader(dataset=custom_dataset,
                                           batch_size=64, 
                                           shuffle=False)
</code></pre>
</li>
<li>
<p>预训练模型</p>
<pre><code class="language-python">'''
    预训练的意思是对一些需要耗费时间和资源很多的任务，一些已经做好的人把他们做的参数设置共享出来，大家可以直接使用他们的结果。
    微调的意思是。。不太懂
'''
# Download and load the pretrained ResNet-18.
resnet = torchvision.models.resnet18(pretrained=True)

# If you want to finetune only the top layer of the model, set as below.
for param in resnet.parameters():
    param.requires_grad = False

# Replace the top layer for finetuning.
resnet.fc = nn.Linear(resnet.fc.in_features, 100)  # 100 is an example.

# Forward pass.
images = torch.randn(64, 3, 224, 224)
outputs = resnet(images)
print (outputs.size())     # (64, 100)
</code></pre>
</li>
</ol>
<h3 id="保存以及加载模型">保存以及加载模型</h3>
<pre><code class="language-python"># Save and load the entire model.
torch.save(resnet, 'model.ckpt')
model = torch.load('model.ckpt')

# Save and load only the model parameters (recommended).
torch.save(resnet.state_dict(), 'params.ckpt')
resnet.load_state_dict(torch.load('params.ckpt'))
</code></pre>
<!-- more -->
<!-- more -->

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#pytorch-tutorial-tutorial-01-basics-pytorch_basics-mainpy">pytorch-tutorial-tutorial-01-basics-pytorch_basics-main.py</a><br>
*
<ul>
<li><a href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90%E8%AF%B4%E6%98%8E%E5%A6%82%E4%BD%95%E8%87%AA%E5%8A%A8%E8%AE%A1%E7%AE%97%E5%81%8F%E5%AF%BC%E6%95%B0">第一个例子，说明如何自动计算偏导数</a></li>
<li><a href="#%E7%AC%AC%E4%BA%8C%E4%B8%AA%E4%BE%8B%E5%AD%90%E8%AF%B4%E6%98%8E%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%9E%8B">第二个例子，说明如何使用模型</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E4%BB%8Enumpy%E4%B8%AD%E8%BD%BD%E5%85%A5%E6%95%B0%E6%8D%AE">如何从numpy中载入数据</a></li>
<li><a href="#%E8%BE%93%E5%85%A5pipline">输入pipline</a></li>
<li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E9%9B%86%E7%9A%84%E8%BE%93%E5%85%A5%E7%AE%A1%E9%81%93">自定义数据集的输入管道</a></li>
<li><a href="#%E4%BF%9D%E5%AD%98%E4%BB%A5%E5%8F%8A%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9E%8B">保存以及加载模型</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://AnonymityToAll.github.io/post/leetcode-shua-ti-hui-su/">
              <h3 class="post-title">
                leetcode刷题--回溯
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://AnonymityToAll.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
